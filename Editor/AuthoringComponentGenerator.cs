// SPDX-License-Identifier: Apache-2.0
// © 2023 Nikolay Melnikov <n.melnikov@depra.org>

using System;
using System.Linq;
using Depra.CodeGen.Attributes;
using Depra.CodeGen.Context;
using Depra.CodeGen.Core;
using Depra.Ecs.Hybrid.Components;
using Depra.Ecs.Hybrid.Entities;
using Depra.Ecs.Worlds;
using UnityEngine;

namespace Depra.Ecs.Hybrid.CodeGen.Editor
{
	[Generator]
	internal sealed class AuthoringComponentGenerator : ICodeGenerator
	{
		void ICodeGenerator.Execute(GeneratorContext context)
		{
			var componentTypes = AppDomain.CurrentDomain
				.GetAssemblies()
				.SelectMany(assembly => assembly.GetTypes())
				.Where(type => type.IsValueType && Attribute.IsDefined(type, typeof(BakingComponentAttribute)));

			foreach (var componentType in componentTypes)
			{
				var fields = componentType.GetFields();
				var className = $"{componentType.Name}AuthoringComponent";
				var authoringFields = AuthoringComponentTemplate.GenerateFields(fields);
				var bakerFactory = AuthoringComponentTemplate.GenerateFactory(fields.Length);
				var bakerDefinition = BakerTemplate.GenerateDefinition(fields.Length);
				var componentAllocation = BakerTemplate.GenerateAllocation(componentType.FullName, className, fields);

				var code = @$"//<auto-generated/>
using Depra.Ecs.Hybrid.Components;
using Depra.Ecs.Hybrid.Entities;
using Depra.Ecs.QoL.Entities;
using Depra.Ecs.QoL.Worlds;
using Depra.Ecs.Worlds;
using UnityEngine;

public sealed class {className} : {nameof(MonoBehaviour)}, {nameof(IAuthoring)} 
{{{authoringFields}{bakerFactory}
	private readonly struct Baker : {nameof(IBaker)}
	{{{bakerDefinition}
		void {nameof(IBaker)}.{nameof(IBaker.Bake)}({nameof(IAuthoring)} authoring, {nameof(World)} world)
		{{
			if ((({nameof(IAuthoringEntity)}) authoring).{nameof(IAuthoringEntity.TryGetEntity)}(out var entity))
			{{
				{componentAllocation}
			}}
		}}
	}}
}}";

				context.AddCode($"AuthoringComponents/{className}.cs", code);
			}
		}
	}
}