using System;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Depra.CodeGen.Attributes;
using Depra.CodeGen.Context;
using Depra.CodeGen.Core;
using Depra.Ecs.Baking.CodeGen.Runtime;
using Depra.Ecs.Baking.Runtime.Components;
using Depra.Ecs.Components;
using Depra.Ecs.Entities;
using Depra.Ecs.Worlds;

namespace Depra.Ecs.Baking.CodeGen.Editor
{
	[Generator]
	[SuppressMessage("ReSharper", "ClassNeverInstantiated.Global")]
	public sealed class AuthoringComponentGenerator : ICodeGenerator
	{
		void ICodeGenerator.Execute(GeneratorContext context)
		{
			var componentTypes = AppDomain.CurrentDomain
				.GetAssemblies()
				.SelectMany(assembly => assembly.GetTypes())
				.Where(type => type.IsValueType && Attribute.IsDefined(type, typeof(DefaultBaking)));

			foreach (var componentType in componentTypes)
			{
				var className = $"{componentType.Name}AuthoringComponent";
				var code = @$"//<auto-generated/>
using Depra.Ecs.Baking.Runtime.Components;
using Depra.Ecs.Components;
using Depra.Ecs.Entities;

public sealed class {className} : AuthoringComponent<{componentType.FullName}> 
{{
	public override {nameof(IBaker)} CreateBaker({nameof(PackedEntityWithWorld)} entity) => new Baker(entity);

	private readonly struct Baker : {nameof(IBaker)}
	{{
		private readonly {nameof(PackedEntityWithWorld)} _entity;

		public Baker({nameof(PackedEntityWithWorld)} entity) => _entity = entity;

		void {nameof(IBaker)}.{nameof(IBaker.Bake)}({nameof(IAuthoring)} authoring)
		{{
			if (_entity.{nameof(PackedEntityWithWorldExtensions.Unpack)}(out var world, out var entity))
			{{
				world.{nameof(World.Pool)}<{componentType.FullName}>().{nameof(ComponentPoolExtensions.Replace)}(entity, (({className})authoring).Value);
			}}
		}}
	}}
}}";

				context.AddCode($"AuthoringComponents/{className}.cs", code);
			}
		}
	}
}