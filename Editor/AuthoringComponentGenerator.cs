// SPDX-License-Identifier: Apache-2.0
// © 2023 Nikolay Melnikov <n.melnikov@depra.org>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Depra.CodeGen.Attributes;
using Depra.CodeGen.Context;
using Depra.CodeGen.Core;
using Depra.Ecs.Baking.Components;
using Depra.Ecs.Components;
using Depra.Ecs.QoL.Entities;
using Depra.Ecs.Worlds;
using UnityEngine;

namespace Depra.Ecs.Baking.CodeGen.Editor
{
	[Generator]
	internal sealed class AuthoringComponentGenerator : ICodeGenerator
	{
		private const string DOT = ".";
		private const string GET_POOL_METHOD_NAME = nameof(World.Pool);
		private const string ALLOCATE_METHOD_NAME = nameof(IComponentPool.Allocate);
		private const string GET_POOL_METHOD_FORMAT = "world." + GET_POOL_METHOD_NAME + "<{0}>()";
		private const string ALLOCATE_METHOD_FORMAT = GET_POOL_METHOD_FORMAT + DOT + ALLOCATE_METHOD_NAME + "(entity)";

		private static string ComponentAllocation(string componentName, string authoringName,
			IReadOnlyList<FieldInfo> componentFields) => componentFields.Count switch
		{
			0 => string.Format(ALLOCATE_METHOD_FORMAT, componentName) + ";",
			1 => string.Format(ALLOCATE_METHOD_FORMAT, componentName) +
			     $".{componentFields[0].Name} = (({authoringName})authoring).{componentFields[0].Name.ToCamelCaseWithUnderscore()};",
			_ => $"ref var component = ref {string.Format(ALLOCATE_METHOD_FORMAT, componentName)};\n\t\t\t\t" +
			     string.Join("\n\t\t\t\t", componentFields.Select(field =>
				     $"component.{field.Name} = (({authoringName})authoring).{field.Name.ToCamelCaseWithUnderscore()};"))
		};

		void ICodeGenerator.Execute(GeneratorContext context)
		{
			var componentTypes = AppDomain.CurrentDomain
				.GetAssemblies()
				.SelectMany(assembly => assembly.GetTypes())
				.Where(type => type.IsValueType && Attribute.IsDefined(type, typeof(BakingComponentAttribute)));

			foreach (var componentType in componentTypes)
			{
				var className = $"{componentType.Name}AuthoringComponent";
				var componentFields = componentType.GetFields();
				var authoringFields = string.Empty;
				if (componentFields.Length > 0)
				{
					authoringFields += "\n";
					authoringFields = componentFields.Aggregate(authoringFields, (current, field) => current +
						$"\t[{nameof(SerializeField)}] private {field.FieldType.FullName} {field.Name.ToCamelCaseWithUnderscore()};\n");
				}

				var componentAllocation = ComponentAllocation(componentType.FullName, className, componentFields);

				var code = @$"//<auto-generated/>
using Depra.Ecs.Baking.Components;
using Depra.Ecs.QoL.Entities;
using Depra.Ecs.QoL.Worlds;
using UnityEngine;

public sealed class {className} : {nameof(MonoBehaviour)}, {nameof(IAuthoring)} 
{{{authoringFields}
	{nameof(IBaker)} {nameof(IAuthoring)}.{nameof(IAuthoring.CreateBaker)}({nameof(PackedEntityWithWorld)} entity) => new Baker(entity);

	private readonly struct Baker : {nameof(IBaker)}
	{{
		private readonly {nameof(PackedEntityWithWorld)} _entity;

		public Baker({nameof(PackedEntityWithWorld)} entity) => _entity = entity;

		void {nameof(IBaker)}.{nameof(IBaker.Bake)}({nameof(IAuthoring)} authoring)
		{{
			if (_entity.{nameof(PackedEntity.Unpack)}(out var world, out var entity))
			{{
				{componentAllocation}
			}}
		}}
	}}
}}";

				context.AddCode($"AuthoringComponents/{className}.cs", code);
			}
		}
	}
}